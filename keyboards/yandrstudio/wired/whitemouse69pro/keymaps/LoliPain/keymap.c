/* Copyright 2021 JasonRen(biu)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
*/


/*
	⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⣠⣾⣿⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣝⢿⣿⣿⣿⣯⢿⣿⣷⡀⠀⠊⠱⣄⠀⠀⠀⠀⠀⠀⠀
	⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⣠⣾⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⠿⣿⣿⣷⡉⠙⢷⣦⠀⠀⠘⢦⠀⠀⠀⠀⠀⠀
	⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢷⡘⢿⣿⣷⡀⠈⣯⣇⠈⢦⡈⣦⠀⠀⠀⠀⠀
	⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠀⢠⣟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣸⣿⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⡟⢿⠆⠳⠄⢿⣿⣷⡀⢸⡼⣆⠀⠘⠎⣆⠀⠀⠀⠀
	⠀⠀⠀⠀⠀⠀⠀⡼⠁⠀⢠⣿⣿⣿⣿⣿⠛⠛⣹⡟⢿⣿⢫⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⢹⠋⣿⣿⣿⣷⣿⣿⡿⣿⣿⣿⡿⠀⠀⠀⠈⢄⢻⣿⣷⣿⣧⢹⣦⣀⠀⠸⡄⠀⠀⠀
	⠀⠀⠀⠀⠀⠀⡜⠁⠀⢀⣾⣿⣿⣿⣿⣧⡀⢸⣿⢀⡼⠁⣸⣿⣿⣿⠉⠛⠛⢣⡿⠋⡿⢸⢰⠻⠿⠏⡟⣿⠌⠉⢻⣿⣧⣠⣤⡄⠀⠀⣌⢧⣿⣿⣿⣿⡎⣧⡉⠙⣲⣷⡠⣄⠀
	⠀⠀⠀⠀⠀⣼⠁⠀⢠⣾⢳⣿⣿⣿⣿⣿⣧⣿⣿⡟⠁⠀⣿⣿⡿⣇⠀⠀⠀⢸⠀⠀⡇⠸⠸⡄⠀⠀⣇⢻⣴⠀⣮⣿⣿⣿⠋⢿⣶⡾⠿⣷⣿⣿⣿⣿⡇⢣⠈⠙⢛⢾⣷⡌⠂
	⠀⠀⠀⠀⢰⠃⠀⢠⡟⢁⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⣿⣿⡇⣿⠀⠀⢸⣾⣦⣸⣄⠀⠀⣿⣄⠀⢻⡜⣿⣧⣸⣿⣿⣇⠀⢸⠏⠀⣰⣿⣿⢿⣿⣿⡇⢸⠀⢠⣿⣾⣿⣧⢠
	⠀⠀⠀⠀⡾⠀⣰⡟⠀⢸⣿⣿⣿⣿⣿⣿⣿⡟⠈⠲⣄⠀⣿⣿⡇⢹⣷⣦⣸⢸⣿⣿⣿⡆⠀⢸⣿⣷⣼⠇⠘⣿⢿⣿⠋⠁⠀⠀⠀⠘⣿⣿⣿⣾⣿⣿⡇⢸⣶⣿⠃⡟⡿⣿⣄
	⠀⠀⠀⠀⡇⣼⠏⠀⠀⣾⣻⣿⣿⣿⣿⣿⣿⠃⠀⠀⠈⠓⣿⣿⣧⠸⣿⣿⣿⣾⣾⣿⣿⣿⠀⠀⢿⣿⣿⣇⠀⠈⣓⡿⠦⠤⠤⠤⠤⣤⣿⣿⣿⣷⢿⣿⡇⢸⣿⠃⡼⢀⡇⢿⡟
	⠀⠀⠀⠀⣿⠋⠀⠀⠀⡿⣿⣿⣿⣿⣿⢸⣿⡀⠀⠀⠀⠀⢹⣿⣿⠤⣿⣿⣿⣿⡟⢻⣿⣿⣄⠀⠘⣿⣿⣿⡌⠁⠘⠷⣤⡀⠁⢀⠀⠀⡿⠋⠙⢻⣿⣿⡇⣼⣷⣾⣇⣼⠁⣾⣇		
	⠀⠀⠀⢠⡇⠀⠀⠀⣸⡏⣿⣿⣿⣿⣿⣿⡏⣇⠀⠀⠀⠠⠼⣿⣿⣆⢸⣿⣿⣻⣷⡈⢿⡀⠙⡄⠀⣸⣿⣿⣷⡀⠀⠀⠀⠈⢹⣷⣶⣾⣿⣀⣠⣿⣿⣿⡇⣿⢁⣿⣿⠃⠀⡿⣿		
	⠀⠀⢀⡟⡇⠀⠀⠀⣿⣷⣿⣿⣿⣿⡇⣿⣧⣼⣷⣿⢿⣿⡿⣾⣯⡛⠆⠙⢷⣿⠿⠷⠀⠙⠶⣟⣻⣯⣼⣿⣿⣿⣆⠀⠀⠀⠘⢻⣿⣽⣿⣿⣿⣿⣿⣿⢧⡇⣾⣿⡇⠀⠀⠁⡿		
	⠀⠀⣸⠀⣧⠀⠀⢸⢛⣿⣿⣿⣿⣿⣧⣿⡿⣿⠋⠀⢸⣿⣿⣿⣙⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣹⣿⣬⡭⠛⢿⣿⣦⣄⠀⠀⣿⣿⣿⠿⣛⣛⢿⡿⣼⢸⣿⣽⣇⠀⠀⠀⡇		
	⠀⢰⡇⠀⠸⡄⠀⢸⢸⣿⣿⣿⣿⣿⣿⡇⡇⠛⠂⠀⢸⠂⢻⣿⡯⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡿⢿⣽⣷⢺⣿⠙⢿⡭⣥⡿⠟⠁⠘⢿⣿⡬⢿⡟⣼⡏⣿⢹⠀⠀⠀⡇				 LoliPain
	⠀⡾⠀⠀⠀⠹⣄⢸⣾⣿⣿⣿⣿⣿⣿⣹⣿⡄⠀⠀⠨⣷⣤⣭⣴⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣻⣤⣈⣙⣩⣿⠏⠀⠉⠀⡸⢹⠧⣴⣧⣄⣿⡇⣿⠁⣿⢿⡿⡎⢀⠀⠀⡇			Epomaker MiniCat 69
	⢸⠇⠀⠀⠀⠀⠈⢸⣿⡿⣿⣿⣿⣿⣿⢿⣟⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠁⠀⠀⠀⠈⠁⠈⣰⣿⣿⣿⠟⢸⣿⣸⣯⣾⠣⠁⠀⠀⠀⡇			
	⣾⠀⠀⠀⠀⠀⢠⣿⣿⣷⢿⣿⣿⣿⣿⣾⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡿⣿⠛⠁⣤⣿⣱⣿⣿⣿⠀⠀⣶⠀⠀⢀
	⣿⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⠏⠈⣿⡟⣿⡟⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀.⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢁⣤⣾⣿⣷⣿⣿⣿⡇⠀⢀⡇⠀⠀⢸				QMK VIM-pref layout
	⡇⠀⠀⠀⢀⣾⣾⣿⣿⣿⣿⣿⡿⠀⢀⡟⢀⡏⠀⡾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⢤⠀⠀⠀⠀⠀⣠⣾⣷⣶⣾⣿⣯⣿⣝⣼⣿⣿⣿⡇⠀⢸⠀⠀⠀⠀
	⣿⣠⠴⢖⢿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠘⣟⣾⠁⢹⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠀⢸⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⢷⣿⡇⣿⡇⠀⣸⠀⠀⠀⠀
	⠙⠷⣤⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⢿⣿⠀⠸⣿⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⢀⡴⣞⣥⣀⣸⣿⣿⣿⣿⣿⣿⢹⣏⣾⣿⡇⣿⠀⠀⡇⠀⠀⠀⠀
	⢀⢼⣷⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠳⣄⠸⣿⠀⠀⣿⠿⣿⣿⣿⣦⣄⠀⠀⠀⣤⢤⡀⠀⠀⠀⣠⡞⠀⢀⣿⣿⠟⠁⢠⢿⣻⣿⣿⣿⣿⣿⣧⣿⣽⣿⣿⡇⣿⡇⠀⡇⠀⠀⠀⠀
	⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠧⠀⠀⠈⢦⣀⣀⣀⡇⠀⢿⣿⣿⡟⠈⡷⣦⡼⠁⢀⣀⣤⣴⢾⣋⠀⣠⣿⠿⠋⠀⣰⣯⣾⣿⣿⣿⣿⣿⣿⣿⣳⣿⣿⣿⣧⣿⣿⢠⡇⠀⠀⠀⠀
	⣿⣿⣿⣿⣿⣟⣿⣿⣿⡇⠀⠀⠈⢦⠀⠈⣧⠀⠉⠉⢳⣼⣿⢿⢁⠞⠁⢀⣭⣷⣞⢿⡭⠗⠉⠉⠙⢯⡀⣀⡤⢞⣿⣿⣿⣿⣿⣹⣿⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⠀⠀⠀⠀⠀
	⣿⣿⣿⣿⣿⡿⠿⣛⠉⠙⢦⠀⠀⠸⡄⢠⣿⣄⣀⣠⣿⣿⣿⣄⣾⣶⣿⣿⣿⣿⡟⠉⠀⢀⡠⠶⠶⣄⡹⢁⣴⣿⣿⣿⣿⣿⣧⣿⣿⣿⣿⠉⠉⠉⣏⠙⠿⣿⣿⣸⠀⠀⠀⠀⠀
	⣿⣿⣿⣿⡿⢡⣾⣿⡇⠀⠈⠳⣄⠀⣷⣠⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⡿⠶⣶⠊⠁⠀⠀⠀⠀⣹⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣾⣿⠿⠛⠉⠹⡍⠉⠉⢙⣿⣆⠀⠀⠀⠀
	⣿⣿⣿⣿⡇⢸⣿⠟⠀⠀⠀⠀⣿⡏⠉⠹⣿⣿⣿⣿⣿⣿⣿⣂⣀⡀⠀⠀⠀⠀⠀⢀⣽⠿⠿⠛⢢⢠⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⡿⠛⠁⠀⠀⠀⠀⠹⣦⡴⠛⠁⠸⡆⠀⠀⠀
	⣿⣿⣿⣵⠃⠚⠃⠀⠀⠀⠀⢸⣿⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⠀⠀⠀⠈⠀⢸⣧⣴⣞⢿⣿⣿⣿⣿⣿⣿⣯⣹⣾⡟⠁⠀⠀⠀⠀⠀⣠⡾⠟⠳⣤⡀⠀⣿⠀⠀⢀
	⣿⣿⠛⠛⠀⠀⠀⠀⣼⡇⢀⣾⣿⣷⣄⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⣾⡿⢡⣿⠘⢿⣿⣿⣿⣿⣷⣿⣿⣿⣶⣤⣤⣤⣴⣶⠿⠋⠀⠀⠀⠀⠉⠒⢾⠴⠒⠉
	⠏⠁⠀⣥⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⣷⣤⣶⡶⠀⠀⣸⡟⠀⢸⣿⠀⠘⣿⣿⣿⣿⢟⣿⣿⣏⠀⠉⠉⠉⢁⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠀⠀⠀
	⣴⣷⣶⠟⠀⠀⢠⣿⣿⣿⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⣼⣿⣿⠁⠀⣰⢿⣤⣴⢻⡿⢀⣼⣿⣿⡿⣣⣿⣿⡿⠘⣇⠀⢀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣀⣀⣠
	⣿⣿⣿⠀⠀⠀⣸⣿⣿⣏⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⣀⣾⣿⣿⡇⣠⣾⣧⠾⣿⡿⠼⢣⣾⣿⣟⣡⣾⣿⣿⡟⠁⠀⣘⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣟⠉⠁
*/


#include QMK_KEYBOARD_H
#include "types.h"

static bool layers_locked;


const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[_QWERTY] = LAYOUT(
		QK_GESC, KC_1,    KC_2,    KC_3,    KC_4,   KC_5,   KC_6,    KC_7,    KC_8,        KC_9,   KC_0,    KC_MINS, KC_EQL, KC_BSPC, KC_DEL,
		KC_TAB,  KC_Q,    KC_W,    KC_E,    KC_R,   KC_T,   KC_Y,    KC_U,    KC_I,        KC_O,   KC_P,    KC_BSLS, KC_P7,  KC_P8,   KC_P9,
		KC_CAPS, KC_A,    KC_S,    KC_D,    KC_F,   KC_G,   KC_H,    KC_J,    KC_K,        KC_L,   KC_ENT,           KC_P4,  KC_P5,   KC_P6,
		KC_LSFT, KC_Z,    KC_X,    KC_C,    KC_V,   KC_B,   KC_N,    KC_M,    KC_COMM,     KC_DOT, KC_SLSH, KC_UP,   KC_P1,  KC_P2,   KC_P3,
		KC_LCTL, KC_LGUI, KC_LALT, L_SPACE,         XXXXXXX,XXXXXXX, R_SPACE, OSL(_SUPPLY),KC_RALT,KC_LEFT, KC_DOWN, KC_RGHT,KC_P0,   KC_PDOT),
	// Double KC_NO in middle is used for non-existent on MiniCat knob (=
	[_SUPPLY] = LAYOUT(
		KC_PSCR, KC_F1,          KC_F2,   KC_F3,   KC_F4,  KC_F5,  KC_F6,   KC_F7,  KC_F8,   KC_F9,  KC_F10,  KC_F11,  KC_F12, LOCKS,   KC_INS,
		_______, _______,        _______, _______, _______,_______,_______, _______,_______, KC_LBRC,KC_RBRC, _______, _______,_______, KC_HOME,
		_______, _______,        _______, _______, _______,_______,_______, _______,KC_SCLN, KC_QUOT,_______,          _______,_______, KC_PGUP,
		_______, _______,        _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, KC_PGDN,
		_______, OSL(_VIWINDOWS),_______, _______,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, KC_END),
	[_VIMOUSE] = LAYOUT(
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,KC_ACL0, KC_ACL1, KC_ACL2,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,KC_BTN2, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,KC_MS_L, KC_MS_D,KC_MS_U, KC_MS_R,KC_BTN1,          _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, _______),
	[_VIMOVEMENT] = LAYOUT(
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,KC_LEFT, KC_DOWN,KC_UP,   KC_RGHT,_______,          _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, _______),
	[_VIWINDOWS] = LAYOUT(
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,WINPREV, _______,_______, WINNEXT,_______,          _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, _______),
	[_LOCKS] = LAYOUT(
		LLOCK,   _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______,   KC_NLCK,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______,          _______,_______, _______,
		_______, _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______, KC_F23,  _______, _______,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, _______),
	[_RGB] = LAYOUT(
		KC_F24,   RGB_M_P, RGB_M_B, RGB_M_R, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		RGB_MOD,  RGB_HUI, RGB_SAI, RGB_VAI, RGB_SPI,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		RGB_RMOD, RGB_HUD, RGB_SAD, RGB_VAD, RGB_SPD,_______,_______, _______,_______, _______,_______,          _______,_______, _______,
		_______,  _______, _______, _______, _______,_______,_______, _______,_______, _______,_______, _______, _______,_______, _______,
		_______,  _______, _______, RGB_TOG,         XXXXXXX,XXXXXXX, _______,_______, _______,_______, _______, _______,_______, _______)
};


bool locking_layer_blocking(uint16_t keycode, keyrecord_t *record) {
	// Prevent keycodes if layers_locked
	if (layers_locked) {
		switch (keycode) {
			case LOCKS:
				if (record->event.pressed) layers_locked = !layers_locked;
				break;
			default:
				if (record->event.pressed) register_code(keycode);
				else unregister_code(keycode);
		}
		return true;
	} else {
		switch (keycode) {
			case LOCKS:
			// Process LOCKS here instead of MO() due to call queue
				if (record->event.pressed) layer_on(_LOCKS);
				else layer_off(_LOCKS);
				return true;
			case LLOCK:
				if (record->event.pressed) layers_locked = !layers_locked;
				return true;
		}
		return false;
	}
}


bool viwindows_layer_blocking(uint16_t keycode, keyrecord_t *record) {
	// Emulate Ctrl+Win+Left/Right at H/L
	switch (keycode) {
		case WINPREV:
			if (record->event.pressed) tap_code16(LCTL(LGUI(KC_LEFT)));
			return true;
		case WINNEXT:
			if (record->event.pressed) tap_code16(LCTL(LGUI(KC_RGHT)));
			return true;
	}
	return false;
}


bool process_record_user(uint16_t keycode, keyrecord_t *record) {
	// QWERTY layer processing
	switch (keycode) {
		case L_SPACE:
			if (record->event.pressed) register_code(KC_SPC);
			else unregister_code(KC_SPC);
			break;
		case R_SPACE:
			if (record->event.pressed) register_code(KC_SPC);
			else unregister_code(KC_SPC);
			break;
	}
	if (locking_layer_blocking(keycode, record)) return false;
	if (viwindows_layer_blocking(keycode, record)) return false;
	return true;
}

